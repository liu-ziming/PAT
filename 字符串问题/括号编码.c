/*括号匹配题 
圆括号编码（Parencodings）
（来源：POJ 1068 ZOJ 1016，程序设计方法及在线实践指导（王衍等） P204）
问题描述：
令S=s1 s2 …sn是一个正则（well-formed）的圆括号串。S可以编码成2种不同形式：
（1）编码成一个整数序列P=p1 p2 … pn，pi代表在S序列中第i个右圆括号的左圆括号数量。（记为P-序列）
（2）编码成一个整数序列W=w1 w2 … wn，对每一个右圆括号a，编码成一个整数wi，表示从与之匹配的左圆括号开始到a之间的右圆括号的数目（包括a本身）。（记为W-序列）
下面给出一个例子：
S (((()()())))
P-序列  4 5 6 6 6 6（第1个右圆括号前有4个左圆括号，第2个右圆括号前有5个左括号……）
W-序列  1 1 1 4 5 6（第1个右圆括号与它旁边的左圆括号匹配的，则这两个圆括号之间有1个右圆括号，就是第1个右圆括号本身，……）
编程把一个正则圆括号串的P-序列转化为W-序列。

输入：
第一行是一个整数t（1<=t<=10），表示输入数据文件中测试数据的个数。接下来是每个测试数据。每个测试数据的第1行是一个整数n（1<=n<=20），第2行是一个正则圆括号串的P-序列，包含n个正整数，以空格隔开。
输出：
输出有t行，对输入文件每个测试数据所表示的P-序列，输出一行，包含n个整数，表示对应的W-序列。
样例输入：
3
5
4 5 5 5 5
6
4 5 6 6 6 6
9
4 6 6 6 6 8 9 9 9
样例输出：
1 1 3 4 5
1 1 1 4 5 6
1 1 2 4 5 1 1 3 9
解题分析：
	先将一个正则圆括号串的P-序列还原成原始的圆括号串；再根据原始的圆括号串编码成W-序列。
	（1）根据P-序列还原原始圆括号串。把读入的n个整数存放在num数组中，即num[0]~num[n-1]。
	对num[0]的处理是，先写num[0]个左圆括号，然后写1个右圆括号；对num[1]的处理是，先写num[1]-num[0]个左圆括号，然后写1个右圆括号，……，对num[i]的处理是，先写num[i]-num[i-1]个左圆括号，再写1个右圆括号。
	（2）根据原始圆括号串编码成W-序列。对圆括号串中的第i个右圆括号，扫描前面所有圆括号情况，记录为匹配当前扫描到的左右圆括号所需的左圆括号数left；如果当前扫描到的圆括号为左圆括号且left的值刚好为1，则这个左圆括号就是与第i个右圆括号匹配的左圆括号，扫描结束。记录这个扫描过程中扫描到的右圆括号数，这个值就是第i个右圆括号的编码值。

*/

#include <stdio.h>
#include <string.h>

int main()
{
	char kuohao[1000];int left =0;//求w数组，从当前有括号向左，遇到右括号 -1  遇到左括号 +1  ，当left ==1 即为匹配的左括号 
	int n,num[1000];int i,j,k,len,count;   //count 统计 w数组每个位置应该写的左括号数目 
	int w[1000] ;
	scanf("%d",&n);
	for(i=0;i<n;i++)
		scanf("%d",&num[i]);
	for(i=0;i<num[0];i++)
		kuohao[i]='(';
	kuohao[i++]=')';
	for(j=1;j<n;j++)
	{
		for(k=0;k<num[j]-num[j-1];k++)
			kuohao[i++]='(';
		kuohao[i++]=')';
	}
	kuohao[i]='\0';//括号已经复原；
	//求 w数组
	puts(kuohao);
	len=i;i=0;
	for(k=0;k<len;k++)
	{
		
		if(kuohao[k]==')')
		{
			count=1;left=0;     //设置 Left标志用于匹配 括号  
			for(j=k-1;j>=0;j--)
			{
				if(left==1) break;
				if(kuohao[j]==')'){
					count++;left-=1;
				}
				if(kuohao[j]=='('){
					left+=1;
				}
			}
			if(left==1)
				w[i++]=count;//匹配到了左括号，那么记录 遇到了几个有括号 ，也就是w数组 
		}
	 } 
	for(k=0;k<n;k++)
	{
		if(k!=0) printf(" ");
		printf("%d",w[k]);
	}		
 } 







